//! IPLD-specific projection engine that properly handles CIDs
//!
//! CIDs are generated by cim-ipld from event payloads.
//! Events are immutable and verified by their CIDs.

use crate::core::GraphProjection;
use crate::events::{GraphEvent, EventPayload, IpldPayload};
use crate::graphs::ipld_event_chain::{Cid, IpldEventNode, IpldChainEdge};
use uuid::Uuid;
use std::collections::HashMap;

/// IPLD graph projection - built from immutable events
#[derive(Debug)]
pub struct IpldGraphProjection {
    /// Aggregate ID this projection belongs to
    pub aggregate_id: Uuid,
    /// Current version (last event sequence)
    pub version: u64,
    /// IPLD event nodes indexed by CID
    pub nodes: HashMap<String, IpldEventNode>,
    /// Chain edges between nodes
    pub edges: HashMap<String, IpldChainEdge>,
    /// Ordered list of CIDs in the chain
    pub cid_chain: Vec<Cid>,
    /// Additional metadata
    pub metadata: HashMap<String, serde_json::Value>,
}

impl IpldGraphProjection {
    /// Create empty projection for an aggregate
    pub fn new(aggregate_id: Uuid) -> Self {
        Self {
            aggregate_id,
            version: 0,
            nodes: HashMap::new(),
            edges: HashMap::new(),
            cid_chain: Vec::new(),
            metadata: HashMap::new(),
        }
    }
    
    /// Apply an event to update the projection
    pub fn apply(&mut self, event: &GraphEvent, sequence: u64) {
        // Validate event is for this aggregate
        if event.aggregate_id != self.aggregate_id {
            return;
        }
        
        // Update version from JetStream sequence
        self.version = sequence;
        
        // Process IPLD-specific payloads
        if let EventPayload::Ipld(ipld_payload) = &event.payload {
            match ipld_payload {
                IpldPayload::CidAdded { cid, codec, size, data } => {
                    // Store codec and size in projection metadata
                    self.metadata.insert(format!("cid_{}_codec", cid), serde_json::json!(codec));
                    self.metadata.insert(format!("cid_{}_size", cid), serde_json::json!(size));
                    // Create the event payload that would be CID'd
                    let event_payload = crate::graphs::ipld_event_chain::EventPayload {
                        cid: Cid::new(cid),
                        data: crate::core::cim_graph::EventData::NodeAdded {
                            node_id: cid.clone(),
                            node_type: "ipld".to_string(),
                            data: data.clone(),
                        },
                        previous: self.cid_chain.last().cloned(),
                        aggregate_id: self.aggregate_id,
                        sequence,
                    };
                    
                    // Create the node
                    let node = IpldEventNode::new(Cid::new(cid), event_payload);
                    
                    // Add to projection
                    self.nodes.insert(cid.clone(), node);
                    self.cid_chain.push(Cid::new(cid));
                    
                    // If there was a previous CID, create an edge
                    if let Some(prev_cid) = self.cid_chain.get(self.cid_chain.len() - 2) {
                        let edge = IpldChainEdge {
                            id: format!("{}->{}:chain", prev_cid.as_str(), cid),
                            source: prev_cid.clone(),
                            target: Cid::new(cid),
                            link_type: "previous".to_string(),
                        };
                        self.edges.insert(edge.id.clone(), edge);
                    }
                }
                
                IpldPayload::CidLinkAdded { cid, link_name, target_cid } => {
                    // Add a named link between existing CIDs
                    let edge = IpldChainEdge {
                        id: format!("{}->{}:{}", cid, target_cid, link_name),
                        source: Cid::new(cid),
                        target: Cid::new(target_cid),
                        link_type: link_name.clone(),
                    };
                    self.edges.insert(edge.id.clone(), edge);
                    
                    // Update the node's links if it exists
                    if let Some(node) = self.nodes.get_mut(cid) {
                        node.links.insert(link_name.clone(), Cid::new(target_cid));
                    }
                }
                
                IpldPayload::CidPinned { cid, recursive } => {
                    // Track pinning status in projection metadata
                    self.metadata.insert(format!("cid_{}_pinned", cid), serde_json::json!(true));
                    self.metadata.insert(format!("cid_{}_recursive", cid), serde_json::json!(recursive));
                }
                
                IpldPayload::CidUnpinned { cid } => {
                    // Track unpinning in projection metadata
                    self.metadata.insert(format!("cid_{}_pinned", cid), serde_json::json!(false));
                    self.metadata.remove(&format!("cid_{}_recursive", cid));
                }
            }
        }
    }
    
    /// Get the root CID (latest in chain)
    pub fn root_cid(&self) -> Option<&Cid> {
        self.cid_chain.last()
    }
    
    /// Get CID at specific sequence
    pub fn cid_at_sequence(&self, seq: usize) -> Option<&Cid> {
        self.cid_chain.get(seq)
    }
    
    /// Verify the chain integrity
    pub fn verify_chain(&self) -> bool {
        // Each node should reference the previous one
        for i in 1..self.cid_chain.len() {
            let current_cid = &self.cid_chain[i];
            let previous_cid = &self.cid_chain[i - 1];
            
            if let Some(node) = self.nodes.get(current_cid.as_str()) {
                if node.payload.previous.as_ref() != Some(previous_cid) {
                    return false;
                }
            } else {
                return false;
            }
        }
        true
    }
}

impl GraphProjection for IpldGraphProjection {
    type Node = IpldEventNode;
    type Edge = IpldChainEdge;
    
    fn aggregate_id(&self) -> Uuid {
        self.aggregate_id
    }
    
    fn version(&self) -> u64 {
        self.version
    }
    
    fn get_node(&self, node_id: &str) -> Option<&Self::Node> {
        self.nodes.get(node_id)
    }
    
    fn get_edge(&self, edge_id: &str) -> Option<&Self::Edge> {
        self.edges.get(edge_id)
    }
    
    fn nodes(&self) -> Vec<&Self::Node> {
        self.nodes.values().collect()
    }
    
    fn edges(&self) -> Vec<&Self::Edge> {
        self.edges.values().collect()
    }
    
    fn node_count(&self) -> usize {
        self.nodes.len()
    }
    
    fn edge_count(&self) -> usize {
        self.edges.len()
    }
    
    fn edges_between(&self, from: &str, to: &str) -> Vec<&Self::Edge> {
        self.edges.values()
            .filter(|e| e.source.as_str() == from && e.target.as_str() == to)
            .collect()
    }
    
    fn neighbors(&self, node_id: &str) -> Vec<&str> {
        self.edges.values()
            .filter(|e| e.source.as_str() == node_id)
            .map(|e| e.target.as_str())
            .collect()
    }
}

/// Build IPLD projections from event streams
pub fn build_ipld_projection(events: Vec<(GraphEvent, u64)>) -> IpldGraphProjection {
    if events.is_empty() {
        panic!("Cannot build projection from empty event stream");
    }
    
    let aggregate_id = events[0].0.aggregate_id;
    let mut projection = IpldGraphProjection::new(aggregate_id);
    
    for (event, sequence) in events {
        projection.apply(&event, sequence);
    }
    
    projection
}